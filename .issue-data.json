{
  "url": "https://github.com/fumiya-kume/FeLangKit/issues/67",
  "owner": "fumiya-kume",
  "repo": "FeLangKit",
  "issue_number": 67,
  "branch_name": "issue-67-20250529-221750",
  "title": "Implement ExpressionVisitor and StatementVisitor core infrastructure",
  "body": "## Overview\n\nImplement the foundational visitor pattern infrastructure for FeLangKit's AST traversal, starting with the core `ExpressionVisitor<Result>` and `StatementVisitor<Result>` types.\n\nThis is **Phase 1** of the visitor pattern implementation outlined in the [Design Document #65](https://github.com/fumiya-kume/FeLangKit/issues/65).\n\n## Scope\n\n### **Core Infrastructure to Implement:**\n\n1. **ExpressionVisitor<Result>** - Closure-based visitor for Expression AST\n2. **StatementVisitor<Result>** - Closure-based visitor for Statement AST  \n3. **Visitable Protocol** - Unified interface for visitor acceptance\n4. **ASTWalker** - Automatic recursive traversal utilities\n\n## Technical Requirements\n\n### **API Design**\n\n```swift\n// Core visitor structure\npublic struct ExpressionVisitor<Result> {\n    public var visitLiteral: (Literal) -> Result\n    public var visitIdentifier: (String) -> Result\n    public var visitBinary: (BinaryOperator, Expression, Expression) -> Result\n    public var visitUnary: (UnaryOperator, Expression) -> Result\n    public var visitArrayAccess: (Expression, Expression) -> Result\n    public var visitFieldAccess: (Expression, String) -> Result\n    public var visitFunctionCall: (String, [Expression]) -> Result\n    \n    public func visit(_ expression: Expression) -> Result\n}\n\n// Similar structure for StatementVisitor<Result>\npublic struct StatementVisitor<Result> {\n    public var visitIfStatement: (IfStatement) -> Result\n    public var visitWhileStatement: (WhileStatement) -> Result\n    // ... all Statement cases\n    \n    public func visit(_ statement: Statement) -> Result\n}\n\n// Unified traversal interface\npublic protocol Visitable {\n    func accept<V: Visitor>(_ visitor: V) -> V.Result\n}\n```\n\n### **Key Features**\n\n- ✅ **Zero Breaking Changes**: No modifications to existing Expression/Statement enums\n- ✅ **Type Safety**: Generic Result type with compile-time checking\n- ✅ **Thread Safety**: Full `@Sendable` compliance\n- ✅ **Performance**: Efficient pattern matching dispatch\n- ✅ **Extensibility**: Easy to add new visitor types\n\n## Implementation Details\n\n### **File Structure**\n```\nSources/FeLangCore/Visitor/\n├── ExpressionVisitor.swift\n├── StatementVisitor.swift  \n├── Visitable.swift\n├── ASTWalker.swift\n└── docs/\n    └── README.md\n```\n\n### **Pattern Matching Implementation**\n\n```swift\npublic func visit(_ expression: Expression) -> Result {\n    switch expression {\n    case .literal(let literal):\n        return visitLiteral(literal)\n    case .identifier(let name):\n        return visitIdentifier(name)\n    case .binary(let op, let left, let right):\n        return visitBinary(op, left, right)\n    case .unary(let op, let expr):\n        return visitUnary(op, expr)\n    case .arrayAccess(let array, let index):\n        return visitArrayAccess(array, index)\n    case .fieldAccess(let object, let field):\n        return visitFieldAccess(object, field)\n    case .functionCall(let name, let args):\n        return visitFunctionCall(name, args)\n    }\n}\n```\n\n## Testing Requirements\n\n### **Unit Tests**\n- All visitor methods properly dispatch to correct closures\n- Generic Result types work correctly (String, Void, custom types)\n- Thread safety validation with concurrent access\n- Performance benchmarks vs. direct switch statements\n\n### **Test Cases**\n```swift\nfunc testExpressionVisitorBasicFunctionality() {\n    let visitor = ExpressionVisitor<String>(\n        visitLiteral: { \"Literal(\\($0))\" },\n        visitIdentifier: { \"Id(\\($0))\" },\n        visitBinary: { op, left, right in \"Binary(\\(op), \\(left), \\(right))\" },\n        // ... other closures\n    )\n    \n    let expr = Expression.binary(.add, .literal(.integer(1)), .literal(.integer(2)))\n    let result = visitor.visit(expr)\n    \n    XCTAssertEqual(result, \"Binary(+, Literal(integer(1)), Literal(integer(2)))\")\n}\n```\n\n## Performance Requirements\n\n- **Target**: Within 5% of direct switch statement performance\n- **Memory**: No additional heap allocations during traversal\n- **Concurrency**: Support concurrent visitors on different threads\n\n## Documentation\n\n- Complete API documentation with examples\n- Usage patterns and best practices\n- Migration guide from switch statements\n- Performance characteristics and benchmarks\n\n## Definition of Done\n\n- [ ] Core ExpressionVisitor<Result> implemented with all closure properties\n- [ ] Core StatementVisitor<Result> implemented with all Statement cases  \n- [ ] Visitable protocol with default implementations\n- [ ] ASTWalker for recursive traversal\n- [ ] Comprehensive unit test suite (>95% coverage)\n- [ ] Performance benchmarks showing <5% overhead\n- [ ] Complete API documentation with examples\n- [ ] Integration test with existing Expression/Statement usage\n\n## Dependencies\n\n- Must work with existing Expression enum (no modifications)\n- Must work with existing Statement enum (no modifications)  \n- Must maintain @Sendable compliance\n- Must integrate with SymbolTable and error reporting systems\n\n---\n\n**Priority**: High  \n**Complexity**: Medium  \n**Estimated Effort**: 3-4 days\n\n**Related Issues**: #64, #65",
  "state": "open",
  "labels": [],
  "assignees": [
    "fumiya-kume"
  ],
  "milestone": null,
  "created_at": "2025-05-26T00:33:07Z",
  "updated_at": "2025-05-28T23:43:39Z",
  "author": "fumiya-kume",
  "pr_title": "Resolve #67: Implement ExpressionVisitor and StatementVisitor core infrastructure"
}
