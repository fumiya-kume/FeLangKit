{
  "url": "https://github.com/fumiya-kume/FeLangKit/issues/63",
  "owner": "fumiya-kume",
  "repo": "FeLangKit",
  "issue_number": 63,
  "branch_name": "issue-63-20250530-140807",
  "title": "Define `SemanticError` types and reporting",
  "body": "# Define `SemanticError` types and reporting\n\n## 📋 Problem Statement\n\nBased on investigation of the current codebase, FeLangKit has **robust semantic error foundations** but lacks a **complete error reporting infrastructure** to integrate with the existing sophisticated error handling system.\n\n### Current State Analysis\n\n#### ✅ **Existing Assets**\n- **`SemanticError.swift`** (269 lines): Comprehensive enum with 35+ semantic error types covering:\n  - Type mismatches and conversions\n  - Variable scope and declaration errors  \n  - Function call validation\n  - Control flow issues\n  - Array/record access errors\n  - Analysis limitations and recovery\n- **`FeType` system**: Complete type system with compatibility checking\n- **`SemanticAnalysisResult`**: Structured result type with errors, warnings, and symbol table\n- **`SemanticWarning`**: Warning types for unused symbols, implicit conversions, etc.\n- **`SymbolTable.swift`** (446 lines): Full implementation with scope management, thread safety, and built-in functions\n\n#### ❌ **Missing Components**\n- **`SemanticAnalyzer.swift`**: File doesn't exist (empty coordinator)\n- **Error reporting integration**: No connection between `SemanticError` and existing `ErrorFormatter`\n- **Golden file testing**: No semantic error test coverage in the comprehensive test suite (325 passing tests cover tokenization/parsing only)\n\n#### 🏗️ **Existing Error Infrastructure** \nFeLangKit has a sophisticated component-based error system:\n- `ErrorFormatter` with `ErrorMessageComponent` and `ErrorMessageBuilder`\n- `CommonErrorPattern` enum for reusable error formatting\n- Golden file testing system with comprehensive coverage\n- Position-aware error reporting with source context\n\n## 🎯 Goals\n\n### Primary Goals\n- **Integrate semantic errors** with existing `ErrorFormatter` infrastructure\n- **Create semantic error reporter** class for error collection and formatting\n- **Establish golden file testing** for semantic error scenarios\n- **Provide actionable error messages** with source context and suggestions\n\n### Secondary Goals  \n- **Performance optimization**: Error collection with configurable limits\n- **Error deduplication**: Avoid redundant error reporting\n- **Thread safety**: Support concurrent semantic analysis\n- **Extensibility**: Foundation for advanced semantic analysis features\n\n## 🔧 Implementation Plan\n\n### Option Analysis\n\n#### Option 1: Minimal Integration\nAdd basic `SemanticError` formatting to existing `ErrorFormatter`\n- **Pros**: Quick implementation, minimal changes\n- **Cons**: Doesn't leverage existing infrastructure, limited extensibility\n\n#### Option 2: Comprehensive Integration (Recommended)\nCreate `SemanticErrorReporter` class integrated with existing error patterns\n- **Pros**: Leverages existing high-quality infrastructure, extensible, consistent UX\n- **Cons**: More implementation work, requires careful integration\n\n### Chosen Approach: **Comprehensive Integration**\n\n### Phase 1: Core Error Reporting (Week 1)\n- [ ] **Create `SemanticErrorReporter` class**\n  - Error collection with deduplication\n  - Integration with `SymbolTable` for context\n  - Configurable error thresholds (default: 100 errors)\n- [ ] **Extend `ErrorFormatter`** \n  - Add semantic error pattern support\n  - Integrate with existing `CommonErrorPattern`\n  - Source context extraction for semantic errors\n\n### Phase 2: Integration & Testing (Week 2)  \n- [ ] **Golden file test infrastructure**\n  - Semantic error test cases in `Tests/FeLangCoreTests/SemanticError/`\n  - Test categories: type errors, scope errors, semantic violations\n  - Integration with existing test runner patterns\n- [ ] **Integration testing**\n  - End-to-end parser → semantic analysis pipeline\n  - Error message quality validation\n  - Performance benchmarking\n\n### Phase 3: Documentation & Polish (Week 3)\n- [ ] **API documentation** and usage examples\n- [ ] **Error message tuning** based on usability testing  \n- [ ] **Performance optimization** and memory management\n- [ ] **Integration with issue #61** (SemanticAnalyzer coordinator)\n\n## 📊 Technical Requirements\n\n### Error Collection\n```swift\nclass SemanticErrorReporter {\n    func report(_ error: SemanticError)\n    func reportWarning(_ warning: SemanticWarning) \n    func hasErrors: Bool\n    func errorCount: Int\n    func getErrorsSorted() -> [SemanticError]\n}\n```\n\n### Error Formatting\n```swift\nextension ErrorFormatter {\n    static func format(_ semanticError: SemanticError) -> String\n    static func formatWithContext(_ semanticError: SemanticError, symbolTable: SymbolTable) -> String\n}\n```\n\n### Performance Targets\n- **Error Collection**: Thread-safe with minimal overhead\n- **Error Formatting**: <1ms per error for typical cases\n- **Memory Usage**: Linear growth, no leaks with large error counts\n- **Integration**: <5% overhead on parsing pipeline\n\n## 🧪 Testing Strategy\n\n### Test Categories\n1. **Unit Tests**: `SemanticErrorReporter` functionality\n2. **Integration Tests**: Parser pipeline with semantic error reporting  \n3. **Golden File Tests**: Expected error output validation\n4. **Performance Tests**: Large programs with many errors\n5. **Edge Cases**: Unicode identifiers, boundary conditions\n\n### Example Test Cases\n```\nTests/FeLangCoreTests/SemanticError/\n├── GoldenFiles/\n│   ├── type-errors.golden\n│   ├── scope-errors.golden  \n│   └── semantic-violations.golden\n└── TestCases/\n    ├── TypeMismatch/\n    ├── UndeclaredVariable/\n    └── CyclicDependency/\n```\n\n## 🔗 Dependencies & Integration\n\n### Related Issues\n- **Issue #61**: SemanticAnalyzer coordinator (blocks implementation)\n- **Issue #62**: SymbolTable implementation (✅ complete) \n- **Issue #64**: Visitor pattern for semantic analysis\n\n### Integration Points\n- **Existing `ErrorFormatter`**: Extend for semantic error support\n- **Golden file infrastructure**: Reuse existing test patterns\n- **`SymbolTable`**: Leverage for error context and suggestions\n- **Parser pipeline**: Integrate semantic analysis phase\n\n## ✅ Acceptance Criteria\n\n### Functional Requirements\n- [ ] **Error reporting API** supports all existing semantic error types\n- [ ] **Error deduplication** prevents duplicate error messages\n- [ ] **Source context** included in all error messages where applicable\n- [ ] **Performance** meets targets (see Technical Requirements)\n\n### Quality Requirements  \n- [ ] **Test coverage**: >90% for error reporting components\n- [ ] **Error message quality**: Clear, actionable, with helpful suggestions\n- [ ] **API consistency**: Follows existing FeLangCore patterns\n- [ ] **Documentation**: Complete API docs and usage examples\n\n### Integration Requirements\n- [ ] **Backward compatibility**: No breaking changes to existing APIs\n- [ ] **Golden file tests**: Comprehensive semantic error coverage\n- [ ] **Pipeline integration**: Seamless semantic analysis in parser flow\n- [ ] **Thread safety**: Safe for concurrent use\n\n## 📈 Success Metrics\n\n- **Error Detection**: All semantic errors caught before runtime\n- **Message Quality**: Error messages provide actionable feedback\n- **Performance**: <5% parsing overhead with semantic analysis\n- **Test Coverage**: Golden file tests covering major semantic error categories\n- **Integration**: Clean integration with existing error handling infrastructure\n\n---\n\n**Next Steps**: This issue establishes the foundation for semantic error reporting. Implementation should coordinate with issue #61 (SemanticAnalyzer) for the complete semantic analysis pipeline.",
  "state": "open",
  "labels": [],
  "assignees": [
    "fumiya-kume"
  ],
  "milestone": null,
  "created_at": "2025-05-26T00:30:15Z",
  "updated_at": "2025-05-26T10:28:15Z",
  "author": "fumiya-kume",
  "pr_title": "Resolve #63: Define `SemanticError` types and reporting"
}
