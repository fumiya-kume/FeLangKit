{
  "url": "https://github.com/fumiya-kume/FeLangKit/issues/65",
  "owner": "fumiya-kume",
  "repo": "FeLangKit",
  "issue_number": 65,
  "branch_name": "issue-65-20250529-224541",
  "title": "Design Document: Visitor Pattern Infrastructure Implementation",
  "body": "## Step 1 — Problem Statement\n\nFeLangKit currently lacks a visitor pattern infrastructure for traversing and processing AST nodes (`Expression` and `Statement` enums). This limitation creates several issues:\n\n1. **Code Duplication**: Each module that needs to traverse ASTs (PrettyPrinter, future SemanticAnalyzer, code generators) implements its own traversal logic with large switch statements\n2. **Maintainability**: Adding new AST node types requires updating multiple switch statements across different modules\n3. **Extensibility**: Third-party developers cannot easily add new AST processing capabilities without modifying core files\n\nThe current `PrettyPrinter` demonstrates this problem with 387 lines of repetitive switch-case traversal logic that will be duplicated in semantic analysis, code generation, and optimization passes.\n\n## Step 2 — Goal / Non-Goals\n\n**Goals:**\n- Implement a type-safe visitor pattern for `Expression` and `Statement` ASTs\n- Enable clean separation of concerns between AST structure and processing logic\n- Support both mutable and immutable visitors for different use cases\n- Provide convenient base implementations for common traversal patterns\n- Maintain Swift's value semantics and thread safety (`Sendable` compliance)\n- Enable easy extension for future AST node types\n\n**Non-Goals:**\n- Breaking changes to existing `Expression` and `Statement` APIs\n- Performance optimization of existing code (focus on maintainability)\n- Complex visitor composition patterns (keep it simple for v1)\n- Supporting non-AST visitor patterns in this iteration\n\n## Step 3 — Current State Analysis\n\n### **AST Structure Analysis**\n\nThe codebase has two main AST hierarchies:\n\n**Expression AST** (`Sources/FeLangCore/Expression/Expression.swift:4-18`):\n```swift\npublic indirect enum Expression {\n    case literal(Literal)\n    case identifier(String)\n    case binary(BinaryOperator, Expression, Expression)\n    case unary(UnaryOperator, Expression)\n    case arrayAccess(Expression, Expression)\n    case fieldAccess(Expression, String)\n    case functionCall(String, [Expression])\n}\n```\n\n**Statement AST** (`Sources/FeLangCore/Parser/Statement.swift:1-22`):\n```swift\npublic indirect enum Statement {\n    case ifStatement(IfStatement)\n    case whileStatement(WhileStatement)\n    case forStatement(ForStatement)\n    case assignment(Assignment)\n    case variableDeclaration(VariableDeclaration)\n    case constantDeclaration(ConstantDeclaration)\n    case functionDeclaration(FunctionDeclaration)\n    case procedureDeclaration(ProcedureDeclaration)\n    case returnStatement(ReturnStatement)\n    case expressionStatement(Expression)\n    case breakStatement\n    case block([Statement])\n}\n```\n\n### **Current Traversal Patterns**\n\n1. **PrettyPrinter** (`Sources/FeLangCore/PrettyPrinter/PrettyPrinter.swift:45-74`): 387 lines with manual switch statements\n2. **Semantic Analysis**: Empty placeholder (`Sources/FeLangCore/Semantic/SemanticAnalyzer.swift`) awaiting implementation\n3. **Tests**: Heavy manual AST construction and inspection patterns\n\n### **Key Dependencies**\n- SwiftSyntax for advanced parsing (already integrated)\n- Thread-safe design with `@Sendable` conformance required\n- Must integrate with existing `SymbolTable` and error reporting systems\n\n## Step 4 — Option Exploration\n\n### **Option A: Protocol-Based Visitor**\n\n**Approach**: Define visitor protocols with methods for each AST node type.\n\n```swift\npublic protocol ExpressionVisitor {\n    associatedtype Result\n    func visitLiteral(_ literal: Literal) -> Result\n    func visitIdentifier(_ identifier: String) -> Result\n    func visitBinary(_ op: BinaryOperator, _ left: Expression, _ right: Expression) -> Result\n    // ... other methods\n}\n\nextension Expression {\n    func accept<V: ExpressionVisitor>(_ visitor: V) -> V.Result {\n        // switch statement dispatching to visitor methods\n    }\n}\n```\n\n**Pros**: Type-safe, clear separation of concerns, familiar pattern  \n**Cons**: Requires modifying core AST types, generic performance overhead  \n**Complexity**: Medium  \n**Risk**: Low - well-established pattern\n\n### **Option B: Function-Based Visitor (Chosen)**\n\n**Approach**: Use Swift's powerful enum pattern matching with closures for maximum flexibility.\n\n```swift\npublic struct ExpressionVisitor<Result> {\n    var visitLiteral: (Literal) -> Result\n    var visitIdentifier: (String) -> Result\n    var visitBinary: (BinaryOperator, Expression, Expression) -> Result\n    // ... other closures\n    \n    public func visit(_ expression: Expression) -> Result {\n        // pattern matching dispatch\n    }\n}\n```\n\n**Pros**: No AST modifications needed, flexible, Swift-idiomatic, easy testing  \n**Cons**: Runtime dispatch, requires careful closure management  \n**Complexity**: Low  \n**Risk**: Very Low\n\n### **Option C: Codegen-Based Visitor**\n\n**Approach**: Use Swift macros to generate visitor infrastructure.\n\n**Pros**: Zero boilerplate, perfect type safety  \n**Cons**: Complex implementation, Swift 5.9+ requirement, debugging difficulty  \n**Complexity**: High  \n**Risk**: High - bleeding edge technology\n\n## Step 5 — Chosen Solution\n\n**Function-Based Visitor (Option B)** for the following reasons:\n\n1. **Zero Breaking Changes**: No modifications to existing AST enums required\n2. **Swift Idiomatic**: Leverages Swift's powerful enum pattern matching and closure features\n3. **Maximum Flexibility**: Easy to create specialized visitors, compose behaviors, and test\n4. **Performance Adequate**: Function pointer dispatch is fast enough for language processing\n5. **Future Proof**: Easy to extend when new AST nodes are added\n\nThe implementation will provide both low-level building blocks and high-level convenience APIs.\n\n## Step 6 — Implementation Plan\n\n### **Phase 1: Core Infrastructure**\n- [ ] **Child Issue**: Implement `ExpressionVisitor<Result>` struct with closure-based dispatch\n- [ ] **Child Issue**: Implement `StatementVisitor<Result>` struct with closure-based dispatch  \n- [ ] **Child Issue**: Add `Visitable` protocol for unified traversal interface\n- [ ] **Child Issue**: Create `ASTWalker` for automatic recursive traversal\n\n### **Phase 2: Common Visitor Types**\n- [ ] **Child Issue**: Implement `ExpressionTransformer` for immutable AST transformations\n- [ ] **Child Issue**: Implement `StatementTransformer` for immutable AST transformations\n- [ ] **Child Issue**: Create `CollectingVisitor` for gathering information during traversal\n- [ ] **Child Issue**: Add `ValidationVisitor` for AST validation and linting\n\n### **Phase 3: Integration & Migration**\n- [ ] **Child Issue**: Refactor `PrettyPrinter` to use visitor pattern (breaking change)\n- [ ] **Child Issue**: Implement semantic analysis skeleton using visitor pattern\n- [ ] **Child Issue**: Add visitor-based AST utilities and helpers\n- [ ] **Child Issue**: Update documentation and examples\n\n### **Phase 4: Testing & Polish**\n- [ ] **Child Issue**: Comprehensive unit tests for all visitor implementations\n- [ ] **Child Issue**: Performance benchmarks vs. existing switch-based code\n- [ ] **Child Issue**: Integration tests with existing parsing pipeline\n- [ ] **Child Issue**: Documentation and usage examples\n\n## Step 7 — Testing Strategy\n\n### **Unit Tests**\n\n**Edge Cases:**\n- Empty AST structures (empty blocks, null expressions)\n- Deeply nested ASTs (recursive structures, complex nesting)\n- Large ASTs (performance validation)\n- Malformed ASTs (error handling)\n\n**Test Inputs/Outputs:**\n```swift\n// Simple literal visitor\nlet visitor = ExpressionVisitor<String>(\n    visitLiteral: { \"Literal(\\($0))\" },\n    visitIdentifier: { \"Id(\\($0))\" },\n    // ...\n)\nlet expr = Expression.literal(.integer(42))\nXCTAssertEqual(visitor.visit(expr), \"Literal(integer(42))\")\n\n// Tree transformation\nlet doubler = ExpressionTransformer(\n    transformLiteral: { \n        if case .integer(let x) = $0 { return .integer(x * 2) }\n        return .literal($0)\n    }\n)\nlet doubled = doubler.transform(.literal(.integer(21)))\nXCTAssertEqual(doubled, .literal(.integer(42)))\n```\n\n### **Integration Tests**\n\n**Critical Flows:**\n1. **Parser → Visitor → SemanticAnalysis**: Full pipeline validation\n2. **AST → Visitor → PrettyPrinter → Reparse**: Round-trip validation  \n3. **Complex Nested Structures**: Ensure deep traversal works correctly\n\n### **Performance Tests**\n- **Baseline**: Current PrettyPrinter switch statement performance\n- **Target**: Visitor pattern within 10% of baseline performance\n- **Large AST**: 10,000+ node AST processing time\n\n## Step 8 — Performance, Security, Observability\n\n### **Performance Impact**\n- **Expected**: 5-10% overhead from function pointer dispatch vs. direct switch\n- **Mitigation**: Inline closures where possible, provide specialized fast paths\n- **Monitoring**: Benchmark suite in CI pipeline\n\n### **Security**\n- **Thread Safety**: All visitors must be `@Sendable` compliant\n- **Memory Safety**: Avoid retain cycles in recursive visitors\n- **Resource Limits**: Stack overflow protection for deep ASTs\n\n### **Observability**\n- **Metrics**: AST node visit counts, traversal depth, processing time\n- **Logging**: Configurable visitor execution tracing for debugging\n- **Error Reporting**: Clear error messages when visitor closures throw\n\n## Step 9 — Open Questions & Risks\n\n### **Open Questions**\n1. **Performance**: Should we provide both visitor and direct switch APIs during transition?\n2. **Error Handling**: How should visitor errors be propagated and handled?\n3. **Async Support**: Do we need async visitor support for I/O operations?\n4. **Visitor Composition**: Should we support visitor chaining/composition in v1?\n\n### **Risks**\n- **Performance Regression**: Function dispatch might be slower than switch statements\n  - *Mitigation*: Comprehensive benchmarking and optimization\n- **Complexity**: Too many visitor types might confuse users  \n  - *Mitigation*: Start minimal, add based on real usage patterns\n- **Migration Pain**: Existing code will need updates\n  - *Mitigation*: Provide migration guide and backward compatibility period\n\n---\n\n## Action Items\n\n**Immediate Implementation Tasks:**\n\n- [ ] Create `Sources/FeLangCore/Visitor/` module directory structure\n- [ ] Implement core `ExpressionVisitor<Result>` with all closure properties  \n- [ ] Implement core `StatementVisitor<Result>` with all closure properties\n- [ ] Add `Visitable` protocol for unified traversal interface\n- [ ] Create comprehensive test suite for basic visitor functionality\n- [ ] Benchmark visitor performance vs. current PrettyPrinter implementation\n- [ ] Document visitor pattern usage with practical examples\n- [ ] Implement `PrettyPrinter` refactor as proof-of-concept integration\n\n**Follow-up Engineering Work:**\n\n- [ ] **Child Issue**: Advanced visitor types (transformers, collectors, validators)\n- [ ] **Child Issue**: SemanticAnalyzer implementation using visitor pattern  \n- [ ] **Child Issue**: AST optimization passes using visitor infrastructure\n- [ ] **Child Issue**: Code generation backends using visitor pattern\n- [ ] **Child Issue**: Language server protocol integration with visitors\n\n*Generated with Cursor-Agent*",
  "state": "open",
  "labels": [],
  "assignees": [],
  "milestone": null,
  "created_at": "2025-05-26T00:32:43Z",
  "updated_at": "2025-05-26T09:53:05Z",
  "author": "fumiya-kume",
  "pr_title": "Resolve #65: Design Document: Visitor Pattern Infrastructure Implementation"
}
