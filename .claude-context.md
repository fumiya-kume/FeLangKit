# GitHub Issue Context

I need to implement the following GitHub issue:

**Issue #65: Design Document: Visitor Pattern Infrastructure Implementation**

## Step 1 — Problem Statement

FeLangKit currently lacks a visitor pattern infrastructure for traversing and processing AST nodes (`Expression` and `Statement` enums). This limitation creates several issues:

1. **Code Duplication**: Each module that needs to traverse ASTs (PrettyPrinter, future SemanticAnalyzer, code generators) implements its own traversal logic with large switch statements
2. **Maintainability**: Adding new AST node types requires updating multiple switch statements across different modules
3. **Extensibility**: Third-party developers cannot easily add new AST processing capabilities without modifying core files

The current `PrettyPrinter` demonstrates this problem with 387 lines of repetitive switch-case traversal logic that will be duplicated in semantic analysis, code generation, and optimization passes.

## Step 2 — Goal / Non-Goals

**Goals:**
- Implement a type-safe visitor pattern for `Expression` and `Statement` ASTs
- Enable clean separation of concerns between AST structure and processing logic
- Support both mutable and immutable visitors for different use cases
- Provide convenient base implementations for common traversal patterns
- Maintain Swift's value semantics and thread safety (`Sendable` compliance)
- Enable easy extension for future AST node types

**Non-Goals:**
- Breaking changes to existing `Expression` and `Statement` APIs
- Performance optimization of existing code (focus on maintainability)
- Complex visitor composition patterns (keep it simple for v1)
- Supporting non-AST visitor patterns in this iteration

## Step 3 — Current State Analysis

### **AST Structure Analysis**

The codebase has two main AST hierarchies:

**Expression AST** (`Sources/FeLangCore/Expression/Expression.swift:4-18`):
```swift
public indirect enum Expression {
    case literal(Literal)
    case identifier(String)
    case binary(BinaryOperator, Expression, Expression)
    case unary(UnaryOperator, Expression)
    case arrayAccess(Expression, Expression)
    case fieldAccess(Expression, String)
    case functionCall(String, [Expression])
}
```

**Statement AST** (`Sources/FeLangCore/Parser/Statement.swift:1-22`):
```swift
public indirect enum Statement {
    case ifStatement(IfStatement)
    case whileStatement(WhileStatement)
    case forStatement(ForStatement)
    case assignment(Assignment)
    case variableDeclaration(VariableDeclaration)
    case constantDeclaration(ConstantDeclaration)
    case functionDeclaration(FunctionDeclaration)
    case procedureDeclaration(ProcedureDeclaration)
    case returnStatement(ReturnStatement)
    case expressionStatement(Expression)
    case breakStatement
    case block([Statement])
}
```

### **Current Traversal Patterns**

1. **PrettyPrinter** (`Sources/FeLangCore/PrettyPrinter/PrettyPrinter.swift:45-74`): 387 lines with manual switch statements
2. **Semantic Analysis**: Empty placeholder (`Sources/FeLangCore/Semantic/SemanticAnalyzer.swift`) awaiting implementation
3. **Tests**: Heavy manual AST construction and inspection patterns

### **Key Dependencies**
- SwiftSyntax for advanced parsing (already integrated)
- Thread-safe design with `@Sendable` conformance required
- Must integrate with existing `SymbolTable` and error reporting systems

## Step 4 — Option Exploration

### **Option A: Protocol-Based Visitor**

**Approach**: Define visitor protocols with methods for each AST node type.

```swift
public protocol ExpressionVisitor {
    associatedtype Result
    func visitLiteral(_ literal: Literal) -> Result
    func visitIdentifier(_ identifier: String) -> Result
    func visitBinary(_ op: BinaryOperator, _ left: Expression, _ right: Expression) -> Result
    // ... other methods
}

extension Expression {
    func accept<V: ExpressionVisitor>(_ visitor: V) -> V.Result {
        // switch statement dispatching to visitor methods
    }
}
```

**Pros**: Type-safe, clear separation of concerns, familiar pattern  
**Cons**: Requires modifying core AST types, generic performance overhead  
**Complexity**: Medium  
**Risk**: Low - well-established pattern

### **Option B: Function-Based Visitor (Chosen)**

**Approach**: Use Swift's powerful enum pattern matching with closures for maximum flexibility.

```swift
public struct ExpressionVisitor<Result> {
    var visitLiteral: (Literal) -> Result
    var visitIdentifier: (String) -> Result
    var visitBinary: (BinaryOperator, Expression, Expression) -> Result
    // ... other closures
    
    public func visit(_ expression: Expression) -> Result {
        // pattern matching dispatch
    }
}
```

**Pros**: No AST modifications needed, flexible, Swift-idiomatic, easy testing  
**Cons**: Runtime dispatch, requires careful closure management  
**Complexity**: Low  
**Risk**: Very Low

### **Option C: Codegen-Based Visitor**

**Approach**: Use Swift macros to generate visitor infrastructure.

**Pros**: Zero boilerplate, perfect type safety  
**Cons**: Complex implementation, Swift 5.9+ requirement, debugging difficulty  
**Complexity**: High  
**Risk**: High - bleeding edge technology

## Step 5 — Chosen Solution

**Function-Based Visitor (Option B)** for the following reasons:

1. **Zero Breaking Changes**: No modifications to existing AST enums required
2. **Swift Idiomatic**: Leverages Swift's powerful enum pattern matching and closure features
3. **Maximum Flexibility**: Easy to create specialized visitors, compose behaviors, and test
4. **Performance Adequate**: Function pointer dispatch is fast enough for language processing
5. **Future Proof**: Easy to extend when new AST nodes are added

The implementation will provide both low-level building blocks and high-level convenience APIs.

## Step 6 — Implementation Plan

### **Phase 1: Core Infrastructure**
- [ ] **Child Issue**: Implement `ExpressionVisitor<Result>` struct with closure-based dispatch
- [ ] **Child Issue**: Implement `StatementVisitor<Result>` struct with closure-based dispatch  
- [ ] **Child Issue**: Add `Visitable` protocol for unified traversal interface
- [ ] **Child Issue**: Create `ASTWalker` for automatic recursive traversal

### **Phase 2: Common Visitor Types**
- [ ] **Child Issue**: Implement `ExpressionTransformer` for immutable AST transformations
- [ ] **Child Issue**: Implement `StatementTransformer` for immutable AST transformations
- [ ] **Child Issue**: Create `CollectingVisitor` for gathering information during traversal
- [ ] **Child Issue**: Add `ValidationVisitor` for AST validation and linting

### **Phase 3: Integration & Migration**
- [ ] **Child Issue**: Refactor `PrettyPrinter` to use visitor pattern (breaking change)
- [ ] **Child Issue**: Implement semantic analysis skeleton using visitor pattern
- [ ] **Child Issue**: Add visitor-based AST utilities and helpers
- [ ] **Child Issue**: Update documentation and examples

### **Phase 4: Testing & Polish**
- [ ] **Child Issue**: Comprehensive unit tests for all visitor implementations
- [ ] **Child Issue**: Performance benchmarks vs. existing switch-based code
- [ ] **Child Issue**: Integration tests with existing parsing pipeline
- [ ] **Child Issue**: Documentation and usage examples

## Step 7 — Testing Strategy

### **Unit Tests**

**Edge Cases:**
- Empty AST structures (empty blocks, null expressions)
- Deeply nested ASTs (recursive structures, complex nesting)
- Large ASTs (performance validation)
- Malformed ASTs (error handling)

**Test Inputs/Outputs:**
```swift
// Simple literal visitor
let visitor = ExpressionVisitor<String>(
    visitLiteral: { "Literal(\($0))" },
    visitIdentifier: { "Id(\($0))" },
    // ...
)
let expr = Expression.literal(.integer(42))
XCTAssertEqual(visitor.visit(expr), "Literal(integer(42))")

// Tree transformation
let doubler = ExpressionTransformer(
    transformLiteral: { 
        if case .integer(let x) = $0 { return .integer(x * 2) }
        return .literal($0)
    }
)
let doubled = doubler.transform(.literal(.integer(21)))
XCTAssertEqual(doubled, .literal(.integer(42)))
```

### **Integration Tests**

**Critical Flows:**
1. **Parser → Visitor → SemanticAnalysis**: Full pipeline validation
2. **AST → Visitor → PrettyPrinter → Reparse**: Round-trip validation  
3. **Complex Nested Structures**: Ensure deep traversal works correctly

### **Performance Tests**
- **Baseline**: Current PrettyPrinter switch statement performance
- **Target**: Visitor pattern within 10% of baseline performance
- **Large AST**: 10,000+ node AST processing time

## Step 8 — Performance, Security, Observability

### **Performance Impact**
- **Expected**: 5-10% overhead from function pointer dispatch vs. direct switch
- **Mitigation**: Inline closures where possible, provide specialized fast paths
- **Monitoring**: Benchmark suite in CI pipeline

### **Security**
- **Thread Safety**: All visitors must be `@Sendable` compliant
- **Memory Safety**: Avoid retain cycles in recursive visitors
- **Resource Limits**: Stack overflow protection for deep ASTs

### **Observability**
- **Metrics**: AST node visit counts, traversal depth, processing time
- **Logging**: Configurable visitor execution tracing for debugging
- **Error Reporting**: Clear error messages when visitor closures throw

## Step 9 — Open Questions & Risks

### **Open Questions**
1. **Performance**: Should we provide both visitor and direct switch APIs during transition?
2. **Error Handling**: How should visitor errors be propagated and handled?
3. **Async Support**: Do we need async visitor support for I/O operations?
4. **Visitor Composition**: Should we support visitor chaining/composition in v1?

### **Risks**
- **Performance Regression**: Function dispatch might be slower than switch statements
  - *Mitigation*: Comprehensive benchmarking and optimization
- **Complexity**: Too many visitor types might confuse users  
  - *Mitigation*: Start minimal, add based on real usage patterns
- **Migration Pain**: Existing code will need updates
  - *Mitigation*: Provide migration guide and backward compatibility period

---

## Action Items

**Immediate Implementation Tasks:**

- [ ] Create `Sources/FeLangCore/Visitor/` module directory structure
- [ ] Implement core `ExpressionVisitor<Result>` with all closure properties  
- [ ] Implement core `StatementVisitor<Result>` with all closure properties
- [ ] Add `Visitable` protocol for unified traversal interface
- [ ] Create comprehensive test suite for basic visitor functionality
- [ ] Benchmark visitor performance vs. current PrettyPrinter implementation
- [ ] Document visitor pattern usage with practical examples
- [ ] Implement `PrettyPrinter` refactor as proof-of-concept integration

**Follow-up Engineering Work:**

- [ ] **Child Issue**: Advanced visitor types (transformers, collectors, validators)
- [ ] **Child Issue**: SemanticAnalyzer implementation using visitor pattern  
- [ ] **Child Issue**: AST optimization passes using visitor infrastructure
- [ ] **Child Issue**: Code generation backends using visitor pattern
- [ ] **Child Issue**: Language server protocol integration with visitors

*Generated with Cursor-Agent*

**Labels:** 
**Branch:** issue-65-20250529-224541

Please implement this according to the project's coding standards and ensure:
1. All existing tests continue to pass
2. SwiftLint validation passes
3. Code builds successfully
4. Add appropriate tests for new functionality
5. Follow the established architecture patterns

After implementation, please:
1. Create appropriate commits with conventional commit messages
2. Push the branch to origin
3. The PR will be created automatically

Let me know when you're ready to start!

---

*This context file was automatically generated by claude.sh and can be referenced during your Claude Code session.*
